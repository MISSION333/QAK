<!DOCTYPE html>
<html>
<head>
    <title>Graph</title>
    <style>
        /* Add your CSS styles here */
        #section-container {
            width: 80%;
            margin: 0 auto;
        }
        .section {
            display: none;
        }
    </style>
</head>
<body>
    <div id="section-container">
        <h1 id="title">Graph</h1>
        <div id="navigation">
            <button id="prev-btn">Previous</button>
            <button id="next-btn">Next</button>
        </div>
        <div id="sections">
            <!-- Sections will be dynamically added here -->
        </div>
    </div>

    <script>

        const jsonData = {"Title": "Graph", "Sections": [{"SectionTitle": "Introduction", "SectionContent": "A graph is a data structure that represents a set of objects, which we call vertices, and the relationships between those objects, which we call edges. In a graph, vertices are connected to each other by edges. This concept is used to model various real-world situations, including social networks, transportation systems, and computer networks. Graphs can be used to solve problems like finding the shortest path, determining connectivity, and identifying clusters of related objects."}, {"SectionTitle": "Types of Graphs", "SectionContent": "There are several types of graphs, including:\n\n1. Directed Graph: In a directed graph, the edges have a direction. This means that you can only move from one vertex to another along the direction specified by the edge.\n\n2. Undirected Graph: In an undirected graph, the edges have no direction. You can move between any two vertices along the edge in both directions.\n\n3. Weighted Graph: In a weighted graph, each edge is assigned a weight or cost. This weight represents a measure of the cost or distance between the vertices connected by the edge.\n\n4. Bipartite Graph: In a bipartite graph, the vertices can be divided into two disjoint sets such that there are no edges between vertices within the same set.\n\n5. Cyclic Graph: In a cyclic graph, it is possible to traverse the graph and return to the starting vertex by following a path along the edges. In other words, there is at least one cycle in the graph."}, {"SectionTitle": "Graph Representation", "SectionContent": "There are multiple ways to represent a graph in computer memory. Two commonly used representations are:\n\n1. Adjacency Matrix: In this representation, a two-dimensional array is used where the rows and columns represent the vertices, and the value at each index represents the presence or absence of an edge between the vertices.\n\n2. Adjacency List: In this representation, each vertex is associated with a list that contains all its neighboring vertices. This can be implemented using an array of linked lists or an array of arrays.\n\nBoth representations have their advantages and disadvantages, depending on the operations to be performed on the graph."}, {"SectionTitle": "Conclusion", "SectionContent": "Graphs are powerful data structures that allow us to model and solve various problems. Understanding the different types of graphs and their representations is essential for effectively working with graph-based algorithms and applications. By using graphs, we can gain valuable insights and make informed decisions in a wide range of domains."}]};

        const titleElement = document.getElementById("title");
        const sectionsContainer = document.getElementById("sections");
        const prevButton = document.getElementById("prev-btn");
        const nextButton = document.getElementById("next-btn");

        let currentSectionIndex = 0;

        function displaySection(index) {
            sectionsContainer.innerHTML = `<h2>${jsonData.Sections[index].SectionTitle}</h2><p>${jsonData.Sections[index].SectionContent}</p>`;
        }

        // Initial display
        displaySection(currentSectionIndex);

        prevButton.addEventListener("click", () => {
            if (currentSectionIndex > 0) {
                currentSectionIndex--;
                displaySection(currentSectionIndex);
            }
        });

        nextButton.addEventListener("click", () => {
            if (currentSectionIndex < jsonData.Sections.length - 1) {
                currentSectionIndex++;
                displaySection(currentSectionIndex);
            }
        });
    </script>
</body>
</html>
